Index: .idea/compiler.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"CompilerConfiguration\">\n    <bytecodeTargetLevel target=\"11\" />\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/compiler.xml b/.idea/compiler.xml
--- a/.idea/compiler.xml	(revision 4ac3c50a77bd4b1db4af909367d086e256c96773)
+++ b/.idea/compiler.xml	(date 1632155866661)
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="CompilerConfiguration">
-    <bytecodeTargetLevel target="11" />
+    <bytecodeTargetLevel target="14" />
   </component>
-</project>
\ No newline at end of file
+</project>
Index: .idea/runConfigurations.xml
===================================================================
diff --git a/.idea/runConfigurations.xml b/.idea/runConfigurations.xml
deleted file mode 100644
--- a/.idea/runConfigurations.xml	(revision 4ac3c50a77bd4b1db4af909367d086e256c96773)
+++ /dev/null	(revision 4ac3c50a77bd4b1db4af909367d086e256c96773)
@@ -1,13 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="RunConfigurationProducerService">
-    <option name="ignoredProducers">
-      <set>
-        <option value="com.android.tools.idea.compose.preview.runconfiguration.ComposePreviewRunConfigurationProducer" />
-        <option value="org.jetbrains.plugins.gradle.execution.test.runner.AllInPackageGradleConfigurationProducer" />
-        <option value="org.jetbrains.plugins.gradle.execution.test.runner.TestClassGradleConfigurationProducer" />
-        <option value="org.jetbrains.plugins.gradle.execution.test.runner.TestMethodGradleConfigurationProducer" />
-      </set>
-    </option>
-  </component>
-</project>
\ No newline at end of file
Index: mobile/src/main/java/org/openhab/habdroid/background/tiles/AbstractTileService.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * Copyright (c) 2010-2021 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\npackage org.openhab.habdroid.background.tiles\n\nimport android.content.ComponentName\nimport android.content.Context\nimport android.content.Intent\nimport android.content.SharedPreferences\nimport android.content.pm.PackageManager\nimport android.graphics.drawable.Icon\nimport android.os.Build\nimport android.os.Parcelable\nimport android.service.quicksettings.Tile\nimport android.service.quicksettings.TileService\nimport android.util.Log\nimport androidx.annotation.DrawableRes\nimport androidx.annotation.RequiresApi\nimport androidx.annotation.VisibleForTesting\nimport androidx.lifecycle.Lifecycle\nimport androidx.lifecycle.LifecycleOwner\nimport androidx.lifecycle.LifecycleRegistry\nimport androidx.work.WorkInfo\nimport androidx.work.WorkManager\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.launch\nimport kotlinx.parcelize.Parcelize\nimport org.json.JSONException\nimport org.json.JSONObject\nimport org.openhab.habdroid.R\nimport org.openhab.habdroid.background.BackgroundTasksManager\nimport org.openhab.habdroid.background.ItemUpdateWorker\nimport org.openhab.habdroid.background.tiles.AbstractTileService.Companion.getPrefKeyForId\nimport org.openhab.habdroid.ui.PreferencesActivity\nimport org.openhab.habdroid.util.getPrefs\n\n@RequiresApi(Build.VERSION_CODES.N)\nabstract class AbstractTileService : TileService() {\n    @Suppress(\"PropertyName\") @VisibleForTesting abstract val ID: Int\n    private var subtitleUpdateJob: Job? = null\n    private val lifeCycleOwner = object : LifecycleOwner {\n        private val lifecycleRegistry = LifecycleRegistry(this).apply {\n            handleLifecycleEvent(Lifecycle.Event.ON_START)\n        }\n\n        override fun getLifecycle(): Lifecycle {\n            return lifecycleRegistry\n        }\n\n        fun startListening() {\n            lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START)\n        }\n\n        fun stopListening() {\n            lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP)\n        }\n\n        fun destroy() {\n            lifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_DESTROY)\n        }\n    }\n\n    override fun onStartListening() {\n        Log.d(TAG, \"onStartListening()\")\n        qsTile?.let { updateTile(it) }\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n            val workManager = WorkManager.getInstance(applicationContext)\n            val infoLiveData =\n                workManager.getWorkInfosByTagLiveData(BackgroundTasksManager.WORKER_TAG_PREFIX_TILE_ID + ID)\n            infoLiveData.observe(lifeCycleOwner) {\n                updateTileSubtitle()\n            }\n\n            updateTileSubtitle()\n        }\n    }\n\n    override fun onStopListening() {\n        Log.d(TAG, \"onStopListening()\")\n    }\n\n    override fun onTileAdded() {\n        Log.d(TAG, \"onTileAdded()\")\n        qsTile?.let { updateTile(it) }\n    }\n\n    override fun onTileRemoved() {\n        Log.d(TAG, \"onTileRemoved()\")\n    }\n\n    override fun onDestroy() {\n        Log.d(TAG, \"onDestroy()\")\n        super.onDestroy()\n        lifeCycleOwner.stopListening()\n        lifeCycleOwner.destroy()\n    }\n\n    override fun onClick() {\n        Log.d(TAG, \"onClick()\")\n        val data = getPrefs().getTileData(ID)\n        if (data?.item?.isNotEmpty() == true && data.state.isNotEmpty()) {\n            lifeCycleOwner.startListening()\n            if (data.requireUnlock && isLocked) {\n                unlockAndRun { BackgroundTasksManager.enqueueTileUpdate(this, data, ID) }\n            } else {\n                BackgroundTasksManager.enqueueTileUpdate(this, data, ID)\n            }\n        } else {\n            Intent(this, PreferencesActivity::class.java).apply {\n                action = ACTION_QS_TILE_PREFERENCES\n                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)\n                startActivity(this)\n            }\n        }\n    }\n\n    private fun updateTile(tile: Tile) {\n        Log.d(TAG, \"updateTile()\")\n        val data = getPrefs().getTileData(ID)\n\n        tile.apply {\n            state = Tile.STATE_INACTIVE\n            label = data?.tileLabel ?: getString(R.string.tile_number, ID)\n            icon = Icon.createWithResource(this@AbstractTileService, getIconRes(applicationContext, data?.icon))\n            updateTile()\n        }\n    }\n\n    @RequiresApi(Build.VERSION_CODES.Q)\n    private fun updateTileSubtitle() {\n        Log.d(TAG, \"updateTileSubtitle()\")\n\n        val lastInfo = WorkManager\n            .getInstance(applicationContext)\n            .getWorkInfosByTag(BackgroundTasksManager.WORKER_TAG_PREFIX_TILE_ID + ID)\n            .get()\n            .lastOrNull()\n        var lastWorkInfoState = lastInfo?.state\n        val timestamp = lastInfo?.outputData?.getLong(ItemUpdateWorker.OUTPUT_DATA_TIMESTAMP, 0) ?: 0\n        if (lastWorkInfoState?.isFinished == true && timestamp < System.currentTimeMillis() - 5 * 1000) {\n            lastWorkInfoState = null\n        }\n        var updateSubtitleLaterAgain = false\n        val statusRes = when (lastWorkInfoState) {\n            WorkInfo.State.ENQUEUED, WorkInfo.State.BLOCKED -> getString(R.string.item_update_short_status_waiting)\n            WorkInfo.State.RUNNING -> getString(R.string.item_update_short_status_sending)\n            WorkInfo.State.FAILED, WorkInfo.State.CANCELLED -> {\n                updateSubtitleLaterAgain = true\n                getString(R.string.item_update_short_status_failed)\n            }\n            WorkInfo.State.SUCCEEDED -> {\n                updateSubtitleLaterAgain = true\n                ItemUpdateWorker.getShortItemUpdateSuccessMessage(\n                    this,\n                    lastInfo?.outputData?.getString(ItemUpdateWorker.OUTPUT_DATA_SENT_VALUE).orEmpty()\n                )\n            }\n            null -> \"\"\n        }\n        qsTile?.apply {\n            subtitle = statusRes\n            updateTile()\n        }\n        if (statusRes.isEmpty()) {\n            lifeCycleOwner.stopListening()\n        }\n        subtitleUpdateJob?.cancel()\n        if (updateSubtitleLaterAgain) {\n            subtitleUpdateJob = GlobalScope.launch(Dispatchers.Main) {\n                delay(6 * 1000)\n                updateTileSubtitle()\n            }\n        }\n    }\n\n    companion object {\n        private val TAG = AbstractTileService::class.java.simpleName\n        const val TILE_COUNT = 12\n\n        fun getPrefKeyForId(id: Int) = \"tile_data_$id\"\n\n        @DrawableRes fun getIconRes(context: Context, icon: String?): Int = when (icon) {\n            context.getString(R.string.tile_icon_bed_value) -> R.drawable.ic_bed_outline_black_24dp\n            context.getString(R.string.tile_icon_sofa_value) -> R.drawable.ic_sofa_black_24dp\n            context.getString(R.string.tile_icon_bath_value) -> R.drawable.ic_paper_roll_outline_black_24dp\n            context.getString(R.string.tile_icon_house_value) -> R.drawable.ic_home_outline_grey_24dp\n            context.getString(R.string.tile_icon_tree_value) -> R.drawable.ic_tree_outline_grey_24dp\n            context.getString(R.string.tile_icon_light_switch_value) -> R.drawable.ic_light_switch_black_24dp\n            context.getString(R.string.tile_icon_bulb_value) -> R.drawable.ic_lightbulb_outline_black_24dp\n            context.getString(R.string.tile_icon_lamp_ceiling_value) -> R.drawable.ic_ceiling_light_black_24dp\n            context.getString(R.string.tile_icon_lamp_floor_value) -> R.drawable.ic_floor_lamp_black_24dp\n            context.getString(R.string.tile_icon_lamp_bedside_value) -> R.drawable.ic_lamp_black_24dp\n            context.getString(R.string.tile_icon_lamp_outdoor_value) -> R.drawable.ic_outdoor_lamp_black_24dp\n            context.getString(R.string.tile_icon_garage_value) -> R.drawable.ic_garage_black_24dp\n            context.getString(R.string.tile_icon_roller_shutter_value) -> R.drawable.ic_window_shutter_black_24dp\n            context.getString(R.string.tile_icon_battery_value) -> R.drawable.ic_battery_outline_grey_24dp\n            context.getString(R.string.tile_icon_lock_value) -> R.drawable.ic_lock_outline_grey_24dp\n            context.getString(R.string.tile_icon_camera_value) -> R.drawable.ic_webcam_black_24dp\n            context.getString(R.string.tile_icon_tv_value) -> R.drawable.ic_tv_black_24dp\n            context.getString(R.string.tile_icon_radio_value) -> R.drawable.ic_outline_radio_24dp\n            context.getString(R.string.tile_icon_wifi_value) -> R.drawable.ic_wifi_strength_outline_grey_24dp\n            context.getString(R.string.tile_icon_phone_value) -> R.drawable.ic_phone_outline_grey_24dp\n            context.getString(R.string.tile_icon_cloud_upload_value) -> R.drawable.ic_cloud_upload_outline_grey_24dp\n            context.getString(R.string.tile_icon_microphone_value) -> R.drawable.ic_microphone_outline_white_24dp\n            context.getString(R.string.tile_icon_power_plug_value) -> R.drawable.ic_power_plug_outline_grey_24dp\n            context.getString(R.string.tile_icon_color_palette_value) -> R.drawable.ic_palette_outline_grey_24dp\n            context.getString(R.string.tile_icon_switch_value) -> R.drawable.ic_power_settings_black_24dp\n            context.getString(R.string.tile_icon_text_value) -> R.drawable.ic_outline_format_align_left_grey_24dp\n            context.getString(R.string.tile_icon_earth_value) -> R.drawable.ic_earth_grey_24dp\n            context.getString(R.string.tile_icon_star_value) -> R.drawable.ic_star_border_grey_24dp\n            context.getString(R.string.tile_icon_clock_value) -> R.drawable.ic_access_time_white_24dp\n            context.getString(R.string.tile_icon_alarm_clock_value) -> R.drawable.ic_alarm_grey_24dp\n            context.getString(R.string.tile_icon_magnifier_value) -> R.drawable.ic_search_white_24dp\n            context.getString(R.string.tile_icon_baby_value) -> R.drawable.ic_baby_black_24dp\n            context.getString(R.string.tile_icon_child_value) -> R.drawable.ic_account_child_black_24dp\n            context.getString(R.string.tile_icon_man_value) -> R.drawable.ic_face_outline_black_24dp\n            context.getString(R.string.tile_icon_woman_value) -> R.drawable.ic_face_woman_outline_black_24dp\n            context.getString(R.string.tile_icon_person_value) -> R.drawable.ic_person_outline_grey_24dp\n            context.getString(R.string.tile_icon_people_value) -> R.drawable.ic_people_outline_grey_24dp\n            context.getString(R.string.tile_icon_chat_value) -> R.drawable.ic_forum_outline_grey_24dp\n            context.getString(R.string.tile_icon_settings_value) -> R.drawable.ic_settings_outline_grey_24dp\n            context.getString(R.string.tile_icon_shield_value) -> R.drawable.ic_security_grey_24dp\n            context.getString(R.string.tile_icon_fan_value) -> R.drawable.ic_fan_black_24dp\n            context.getString(R.string.tile_icon_bell_value) -> R.drawable.ic_bell_outline_grey_24dp\n            context.getString(R.string.tile_icon_dashboard_value) -> R.drawable.ic_view_dashboard_outline_grey_24dp\n            else -> R.drawable.ic_openhab_appicon_24dp\n        }\n\n        fun requestTileUpdate(context: Context, id: Int) {\n            val data = context.getPrefs().getTileData(id)\n            val tileService = ComponentName(\n                context,\n                getClassNameForId(id)\n            )\n            val tileServiceState = if (data != null) PackageManager.COMPONENT_ENABLED_STATE_ENABLED\n            else PackageManager.COMPONENT_ENABLED_STATE_DISABLED\n            context.packageManager.setComponentEnabledSetting(\n                tileService,\n                tileServiceState,\n                PackageManager.DONT_KILL_APP\n            )\n            requestListeningState(context, tileService)\n        }\n\n        @VisibleForTesting fun getClassNameForId(id: Int) = \"org.openhab.habdroid.background.tiles.TileService$id\"\n        fun getIdFromClassName(className: String) =\n            className.substringAfter(\"org.openhab.habdroid.background.tiles.TileService\").toInt()\n    }\n}\n\n@Parcelize\ndata class TileData(\n    val item: String,\n    val state: String,\n    val label: String,\n    val tileLabel: String,\n    val mappedState: String,\n    val icon: String,\n    val requireUnlock: Boolean\n) : Parcelable {\n    fun isValid(): Boolean {\n        return item.isNotEmpty() &&\n            label.isNotEmpty() &&\n            tileLabel.isNotEmpty() &&\n            mappedState.isNotEmpty() &&\n            icon.isNotEmpty()\n    }\n}\n\nfun SharedPreferences.getTileData(id: Int): TileData? {\n    val tileString = getString(getPrefKeyForId(id), null) ?: return null\n    return try {\n        val obj = JSONObject(tileString)\n        val item = obj.getString(\"item\")\n        val state = obj.getString(\"state\")\n        val label = obj.getString(\"label\")\n        val tileLabel = obj.getString(\"tileLabel\")\n        val mappedState = obj.getString(\"mappedState\")\n        val icon = obj.getString(\"icon\")\n        val requireUnlock = obj.getBoolean(\"requireUnlock\")\n        TileData(item, state, label, tileLabel, mappedState, icon, requireUnlock)\n    } catch (e: JSONException) {\n        null\n    }\n}\n\nfun SharedPreferences.Editor.putTileData(id: Int, data: TileData?): SharedPreferences.Editor {\n    if (data == null) {\n        putString(getPrefKeyForId(id), null)\n    } else {\n        val obj = JSONObject()\n            .put(\"item\", data.item)\n            .put(\"state\", data.state)\n            .put(\"label\", data.label)\n            .put(\"tileLabel\", data.tileLabel)\n            .put(\"mappedState\", data.mappedState)\n            .put(\"icon\", data.icon)\n            .put(\"requireUnlock\", data.requireUnlock)\n            .toString()\n        putString(getPrefKeyForId(id), obj)\n    }\n    return this\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mobile/src/main/java/org/openhab/habdroid/background/tiles/AbstractTileService.kt b/mobile/src/main/java/org/openhab/habdroid/background/tiles/AbstractTileService.kt
--- a/mobile/src/main/java/org/openhab/habdroid/background/tiles/AbstractTileService.kt	(revision 4ac3c50a77bd4b1db4af909367d086e256c96773)
+++ b/mobile/src/main/java/org/openhab/habdroid/background/tiles/AbstractTileService.kt	(date 1632155866635)
@@ -49,7 +49,9 @@
 
 @RequiresApi(Build.VERSION_CODES.N)
 abstract class AbstractTileService : TileService() {
-    @Suppress("PropertyName") @VisibleForTesting abstract val ID: Int
+    @Suppress("PropertyName")
+    @VisibleForTesting
+    abstract val ID: Int
     private var subtitleUpdateJob: Job? = null
     private val lifeCycleOwner = object : LifecycleOwner {
         private val lifecycleRegistry = LifecycleRegistry(this).apply {
@@ -180,7 +182,7 @@
         subtitleUpdateJob?.cancel()
         if (updateSubtitleLaterAgain) {
             subtitleUpdateJob = GlobalScope.launch(Dispatchers.Main) {
-                delay(6 * 1000)
+                delay(6000)
                 updateTileSubtitle()
             }
         }
@@ -192,7 +194,8 @@
 
         fun getPrefKeyForId(id: Int) = "tile_data_$id"
 
-        @DrawableRes fun getIconRes(context: Context, icon: String?): Int = when (icon) {
+        @DrawableRes
+        fun getIconRes(context: Context, icon: String?): Int = when (icon) {
             context.getString(R.string.tile_icon_bed_value) -> R.drawable.ic_bed_outline_black_24dp
             context.getString(R.string.tile_icon_sofa_value) -> R.drawable.ic_sofa_black_24dp
             context.getString(R.string.tile_icon_bath_value) -> R.drawable.ic_paper_roll_outline_black_24dp
@@ -255,7 +258,8 @@
             requestListeningState(context, tileService)
         }
 
-        @VisibleForTesting fun getClassNameForId(id: Int) = "org.openhab.habdroid.background.tiles.TileService$id"
+        @VisibleForTesting
+        fun getClassNameForId(id: Int) = "org.openhab.habdroid.background.tiles.TileService$id"
         fun getIdFromClassName(className: String) =
             className.substringAfter("org.openhab.habdroid.background.tiles.TileService").toInt()
     }
Index: mobile/src/main/java/org/openhab/habdroid/ui/MainActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * Copyright (c) 2010-2021 Contributors to the openHAB project\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\npackage org.openhab.habdroid.ui\n\nimport android.Manifest\nimport android.app.PendingIntent\nimport android.content.ActivityNotFoundException\nimport android.content.ComponentName\nimport android.content.Context\nimport android.content.Intent\nimport android.content.SharedPreferences\nimport android.content.pm.PackageManager\nimport android.content.pm.ShortcutInfo\nimport android.content.pm.ShortcutManager\nimport android.content.res.ColorStateList\nimport android.content.res.Configuration\nimport android.graphics.drawable.Drawable\nimport android.graphics.drawable.Icon\nimport android.location.LocationManager\nimport android.net.wifi.WifiManager\nimport android.nfc.NfcAdapter\nimport android.os.Build\nimport android.os.Bundle\nimport android.provider.Settings\nimport android.speech.SpeechRecognizer\nimport android.text.SpannableStringBuilder\nimport android.text.style.RelativeSizeSpan\nimport android.util.Base64\nimport android.util.Log\nimport android.view.Menu\nimport android.view.MenuItem\nimport android.view.View\nimport android.view.WindowManager\nimport android.widget.ImageView\nimport android.widget.TextView\nimport androidx.annotation.DrawableRes\nimport androidx.annotation.StringRes\nimport androidx.appcompat.app.ActionBarDrawerToggle\nimport androidx.appcompat.app.AlertDialog\nimport androidx.appcompat.widget.Toolbar\nimport androidx.core.content.ContextCompat\nimport androidx.core.content.edit\nimport androidx.core.graphics.drawable.DrawableCompat\nimport androidx.core.graphics.drawable.toDrawable\nimport androidx.core.location.LocationManagerCompat\nimport androidx.core.text.inSpans\nimport androidx.core.view.GravityCompat\nimport androidx.core.view.forEach\nimport androidx.core.view.isGone\nimport androidx.core.view.isVisible\nimport androidx.core.widget.ContentLoadingProgressBar\nimport androidx.drawerlayout.widget.DrawerLayout\nimport androidx.recyclerview.widget.RecyclerView\nimport com.google.android.material.navigation.NavigationView\nimport com.google.android.material.snackbar.Snackbar\nimport java.nio.charset.Charset\nimport java.util.concurrent.CancellationException\nimport javax.jmdns.ServiceInfo\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.GlobalScope\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.launch\nimport okhttp3.Request\nimport org.openhab.habdroid.BuildConfig\nimport org.openhab.habdroid.R\nimport org.openhab.habdroid.background.BackgroundTasksManager\nimport org.openhab.habdroid.background.EventListenerService\nimport org.openhab.habdroid.background.NotificationUpdateObserver\nimport org.openhab.habdroid.core.CloudMessagingHelper\nimport org.openhab.habdroid.core.UpdateBroadcastReceiver\nimport org.openhab.habdroid.core.connection.CloudConnection\nimport org.openhab.habdroid.core.connection.Connection\nimport org.openhab.habdroid.core.connection.ConnectionFactory\nimport org.openhab.habdroid.core.connection.ConnectionNotInitializedException\nimport org.openhab.habdroid.core.connection.DemoConnection\nimport org.openhab.habdroid.core.connection.NetworkNotAvailableException\nimport org.openhab.habdroid.core.connection.NoUrlInformationException\nimport org.openhab.habdroid.model.LinkedPage\nimport org.openhab.habdroid.model.ServerConfiguration\nimport org.openhab.habdroid.model.ServerProperties\nimport org.openhab.habdroid.model.Sitemap\nimport org.openhab.habdroid.model.WebViewUi\nimport org.openhab.habdroid.model.sortedWithDefaultName\nimport org.openhab.habdroid.model.toTagData\nimport org.openhab.habdroid.ui.activity.ContentController\nimport org.openhab.habdroid.ui.homescreenwidget.VoiceWidget\nimport org.openhab.habdroid.ui.homescreenwidget.VoiceWidgetWithIcon\nimport org.openhab.habdroid.ui.preference.toItemUpdatePrefValue\nimport org.openhab.habdroid.ui.widget.LockableDrawerLayout\nimport org.openhab.habdroid.util.AsyncServiceResolver\nimport org.openhab.habdroid.util.CrashReportingHelper\nimport org.openhab.habdroid.util.HttpClient\nimport org.openhab.habdroid.util.ImageConversionPolicy\nimport org.openhab.habdroid.util.PrefKeys\nimport org.openhab.habdroid.util.ScreenLockMode\nimport org.openhab.habdroid.util.Util\nimport org.openhab.habdroid.util.addToPrefs\nimport org.openhab.habdroid.util.areSitemapsShownInDrawer\nimport org.openhab.habdroid.util.determineDataUsagePolicy\nimport org.openhab.habdroid.util.getActiveServerId\nimport org.openhab.habdroid.util.getConfiguredServerIds\nimport org.openhab.habdroid.util.getCurrentWifiSsid\nimport org.openhab.habdroid.util.getDefaultSitemap\nimport org.openhab.habdroid.util.getGroupItems\nimport org.openhab.habdroid.util.getHumanReadableErrorMessage\nimport org.openhab.habdroid.util.getPrefs\nimport org.openhab.habdroid.util.getPrimaryServerId\nimport org.openhab.habdroid.util.getRemoteUrl\nimport org.openhab.habdroid.util.getSecretPrefs\nimport org.openhab.habdroid.util.getStringOrNull\nimport org.openhab.habdroid.util.hasPermissions\nimport org.openhab.habdroid.util.isDebugModeEnabled\nimport org.openhab.habdroid.util.isEventListenerEnabled\nimport org.openhab.habdroid.util.isScreenTimerDisabled\nimport org.openhab.habdroid.util.openInAppStore\nimport org.openhab.habdroid.util.putActiveServerId\nimport org.openhab.habdroid.util.updateDefaultSitemap\n\nclass MainActivity : AbstractBaseActivity(), ConnectionFactory.UpdateListener {\n    private lateinit var prefs: SharedPreferences\n    private var serviceResolveJob: Job? = null\n    private lateinit var drawerLayout: LockableDrawerLayout\n    private lateinit var drawerToggle: ActionBarDrawerToggle\n    private lateinit var drawerMenu: Menu\n    private lateinit var drawerModeSelectorContainer: View\n    private lateinit var drawerModeToggle: ImageView\n    private lateinit var drawerServerNameView: TextView\n    private var drawerIconTintList: ColorStateList? = null\n    lateinit var viewPool: RecyclerView.RecycledViewPool\n        private set\n    private var progressBar: ContentLoadingProgressBar? = null\n    private var sitemapSelectionDialog: AlertDialog? = null\n    var connection: Connection? = null\n        private set\n\n    private var pendingAction: PendingAction? = null\n    private lateinit var controller: ContentController\n    var serverProperties: ServerProperties? = null\n        private set\n    private var propsUpdateHandle: ServerProperties.Companion.UpdateHandle? = null\n    private var retryJob: Job? = null\n    private var isStarted: Boolean = false\n    private var shortcutManager: ShortcutManager? = null\n    private val backgroundTasksManager = BackgroundTasksManager()\n    private var inServerSelectionMode = false\n    private var wifiSsidDuringLastOnStart: String? = null\n\n    override fun onNewIntent(intent: Intent) {\n        super.onNewIntent(intent)\n        CrashReportingHelper.d(TAG, \"onNewIntent()\")\n        processIntent(intent)\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        CrashReportingHelper.d(TAG, \"onCreate()\")\n\n        prefs = getPrefs()\n\n        // Disable screen timeout if set in preferences\n        if (prefs.isScreenTimerDisabled()) {\n            window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)\n        }\n\n        super.onCreate(savedInstanceState)\n\n        val controllerClassName = resources.getString(R.string.controller_class)\n        try {\n            val controllerClass = Class.forName(controllerClassName)\n            val constructor = controllerClass.getConstructor(MainActivity::class.java)\n            controller = constructor.newInstance(this) as ContentController\n        } catch (e: Exception) {\n            Log.wtf(TAG, \"Could not instantiate activity controller class '$controllerClassName'\")\n            throw RuntimeException(e)\n        }\n\n        setContentView(R.layout.activity_main)\n        // inflate the controller dependent content view\n        controller.inflateViews(findViewById(R.id.content_stub))\n\n        setupToolbar()\n        setupDrawer()\n\n        viewPool = RecyclerView.RecycledViewPool()\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N_MR1) {\n            shortcutManager = getSystemService(ShortcutManager::class.java)\n        }\n\n        // Check if we have openHAB page url in saved instance state?\n        if (savedInstanceState != null) {\n            serverProperties = savedInstanceState.getParcelable(STATE_KEY_SERVER_PROPERTIES)\n            val lastConnectionHash = savedInstanceState.getInt(STATE_KEY_CONNECTION_HASH)\n            if (lastConnectionHash != -1) {\n                val c = ConnectionFactory.activeUsableConnection?.connection\n                if (c != null && c.hashCode() == lastConnectionHash) {\n                    connection = c\n                }\n            }\n\n            controller.onRestoreInstanceState(savedInstanceState)\n            val lastControllerClass = savedInstanceState.getString(STATE_KEY_CONTROLLER_NAME)\n            if (controller.javaClass.canonicalName != lastControllerClass) {\n                // Our controller type changed, so we need to make the new controller aware of the\n                // page hierarchy. If the controller didn't change, the hierarchy will be restored\n                // via the fragment state restoration.\n                controller.recreateFragmentState()\n            }\n            if (savedInstanceState.getBoolean(STATE_KEY_SITEMAP_SELECTION_SHOWN)) {\n                showSitemapSelectionDialog()\n            }\n\n            updateSitemapDrawerEntries()\n        }\n\n        processIntent(intent)\n\n        if (prefs.getBoolean(PrefKeys.FIRST_START, true) ||\n            prefs.getBoolean(PrefKeys.RECENTLY_RESTORED, false)\n        ) {\n            NotificationUpdateObserver.createNotificationChannels(this)\n            Log.d(TAG, \"Start intro\")\n            val intent = Intent(this, IntroActivity::class.java)\n            startActivity(intent)\n        }\n        UpdateBroadcastReceiver.updateComparableVersion(prefs.edit())\n\n        val isSpeechRecognizerAvailable = SpeechRecognizer.isRecognitionAvailable(this)\n        GlobalScope.launch {\n            showPushNotificationWarningIfNeeded()\n            manageVoiceRecognitionShortcut(isSpeechRecognizerAvailable)\n            setVoiceWidgetComponentEnabledSetting(VoiceWidget::class.java, isSpeechRecognizerAvailable)\n            setVoiceWidgetComponentEnabledSetting(VoiceWidgetWithIcon::class.java, isSpeechRecognizerAvailable)\n        }\n\n        EventListenerService.startOrStopService(this)\n    }\n\n    override fun onPostCreate(savedInstanceState: Bundle?) {\n        CrashReportingHelper.d(TAG, \"onPostCreate()\")\n        super.onPostCreate(savedInstanceState)\n        // Sync the toggle state after onRestoreInstanceState has occurred.\n        drawerToggle.syncState()\n    }\n\n    override fun onConfigurationChanged(newConfig: Configuration) {\n        CrashReportingHelper.d(TAG, \"onConfigurationChanged()\")\n        super.onConfigurationChanged(newConfig)\n        drawerToggle.onConfigurationChanged(newConfig)\n    }\n\n    override fun onStart() {\n        CrashReportingHelper.d(TAG, \"onStart()\")\n        super.onStart()\n        isStarted = true\n\n        ConnectionFactory.addListener(this)\n\n        updateDrawerServerEntries()\n        onActiveConnectionChanged()\n\n        if (connection != null && serverProperties == null) {\n            controller.clearServerCommunicationFailure()\n            queryServerProperties()\n        }\n\n        val currentWifiSsid = getCurrentWifiSsid()\n        val switchToServer = determineServerIdToSwitchToBasedOnWifi(currentWifiSsid, wifiSsidDuringLastOnStart)\n        wifiSsidDuringLastOnStart = currentWifiSsid\n        if (pendingAction == null && switchToServer != -1) {\n            switchServerBasedOnWifi(switchToServer)\n        }\n        handlePendingAction()\n    }\n\n    public override fun onStop() {\n        CrashReportingHelper.d(TAG, \"onStop()\")\n        isStarted = false\n        super.onStop()\n        ConnectionFactory.removeListener(this)\n        serviceResolveJob?.cancel()\n        serviceResolveJob = null\n        if (sitemapSelectionDialog?.isShowing == true) {\n            sitemapSelectionDialog?.dismiss()\n        }\n        propsUpdateHandle?.cancel()\n    }\n\n    override fun onResume() {\n        CrashReportingHelper.d(TAG, \"onResume()\")\n        super.onResume()\n\n        val nfcAdapter = NfcAdapter.getDefaultAdapter(this)\n        if (nfcAdapter != null) {\n            val intent = Intent(this, javaClass)\n                .addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP)\n            val pi = PendingIntent.getActivity(this, 0, intent, 0)\n            nfcAdapter.enableForegroundDispatch(this, pi, null, null)\n        }\n\n        updateTitle()\n        showMissingPermissionsWarningIfNeeded()\n\n        val intentFilter = BackgroundTasksManager.getIntentFilterForForeground(this)\n        if (intentFilter.countActions() != 0 && !prefs.isEventListenerEnabled()) {\n            registerReceiver(backgroundTasksManager, intentFilter)\n        }\n\n        showDataSaverHintSnackbarIfNeeded()\n    }\n\n    override fun onPause() {\n        CrashReportingHelper.d(TAG, \"onPause()\")\n        super.onPause()\n        retryJob?.cancel(CancellationException(\"onPause() was called\"))\n\n        val nfcAdapter = NfcAdapter.getDefaultAdapter(this)\n        try {\n            nfcAdapter?.disableForegroundDispatch(this)\n        } catch (e: IllegalStateException) {\n            // See #1776\n        }\n\n        try {\n            unregisterReceiver(backgroundTasksManager)\n        } catch (e: IllegalArgumentException) {\n            // Receiver isn't registered\n        }\n    }\n\n    override fun onCreateOptionsMenu(menu: Menu): Boolean {\n        CrashReportingHelper.d(TAG, \"onCreateOptionsMenu()\")\n        val inflater = menuInflater\n        inflater.inflate(R.menu.main_menu, menu)\n        return true\n    }\n\n    override fun onPrepareOptionsMenu(menu: Menu): Boolean {\n        CrashReportingHelper.d(TAG, \"onPrepareOptionsMenu()\")\n        menu.findItem(R.id.mainmenu_voice_recognition).isVisible = connection != null\n        menu.findItem(R.id.mainmenu_crash).isVisible = BuildConfig.DEBUG\n        return true\n    }\n\n    override fun onOptionsItemSelected(item: MenuItem): Boolean {\n        CrashReportingHelper.d(TAG, \"onOptionsItemSelected()\")\n        // Handle back navigation arrow\n        if (item.itemId == android.R.id.home && controller.canGoBack()) {\n            controller.goBack()\n            return true\n        }\n\n        // Handle hamburger menu\n        if (drawerToggle.onOptionsItemSelected(item)) {\n            return true\n        }\n\n        // Handle menu items\n        return when (item.itemId) {\n            R.id.mainmenu_voice_recognition -> {\n                launchVoiceRecognition()\n                true\n            }\n            R.id.mainmenu_crash -> {\n                throw Exception(\"Crash menu item pressed\")\n            }\n            else -> super.onOptionsItemSelected(item)\n        }\n    }\n\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n        super.onActivityResult(requestCode, resultCode, data)\n        CrashReportingHelper.d(TAG, \"onActivityResult() requestCode = $requestCode, resultCode = $resultCode\")\n        when (requestCode) {\n            REQUEST_CODE_SETTINGS -> {\n                if (data == null) {\n                    return\n                }\n                if (data.getBooleanExtra(PreferencesActivity.RESULT_EXTRA_SITEMAP_CLEARED, false)) {\n                    updateSitemapDrawerEntries()\n                    executeOrStoreAction(PendingAction.ChooseSitemap())\n                }\n                if (data.getBooleanExtra(PreferencesActivity.RESULT_EXTRA_SITEMAP_DRAWER_CHANGED, false)) {\n                    updateSitemapDrawerEntries()\n                }\n                if (data.getBooleanExtra(PreferencesActivity.RESULT_EXTRA_THEME_CHANGED, false)) {\n                    recreate()\n                }\n            }\n        }\n    }\n\n    public override fun onSaveInstanceState(savedInstanceState: Bundle) {\n        CrashReportingHelper.d(TAG, \"onSaveInstanceState()\")\n        isStarted = false\n        with(savedInstanceState) {\n            putParcelable(STATE_KEY_SERVER_PROPERTIES, serverProperties)\n            putBoolean(STATE_KEY_SITEMAP_SELECTION_SHOWN, sitemapSelectionDialog?.isShowing == true)\n            putString(STATE_KEY_CONTROLLER_NAME, controller.javaClass.canonicalName)\n            putInt(STATE_KEY_CONNECTION_HASH, connection?.hashCode() ?: -1)\n            controller.onSaveInstanceState(this)\n        }\n        super.onSaveInstanceState(savedInstanceState)\n    }\n\n    override fun onBackPressed() {\n        CrashReportingHelper.d(TAG, \"onBackPressed()\")\n        when {\n            drawerLayout.isDrawerOpen(findViewById<NavigationView>(R.id.left_drawer)) -> drawerLayout.closeDrawers()\n            controller.canGoBack() -> controller.goBack()\n            isFullscreenEnabled -> when {\n                lastSnackbar?.isShown != true ->\n                    showSnackbar(\n                        SNACKBAR_TAG_PRESS_AGAIN_EXIT,\n                        R.string.press_back_to_exit\n                    )\n                lastSnackbar?.view?.tag?.toString() == SNACKBAR_TAG_PRESS_AGAIN_EXIT -> super.onBackPressed()\n                else -> showSnackbar(\n                    SNACKBAR_TAG_PRESS_AGAIN_EXIT,\n                    R.string.press_back_to_exit\n                )\n            }\n            else -> super.onBackPressed()\n        }\n    }\n\n    override fun onActiveConnectionChanged() {\n        CrashReportingHelper.d(TAG, \"onActiveConnectionChanged()\")\n        val result = ConnectionFactory.activeUsableConnection\n        val newConnection = result?.connection\n        val failureReason = result?.failureReason\n\n        if (ConnectionFactory.activeCloudConnection?.connection != null) {\n            manageNotificationShortcut(true)\n        }\n\n        if (newConnection != null && newConnection === connection) {\n            updateDrawerItemVisibility()\n            return\n        }\n\n        retryJob?.cancel(CancellationException(\"onAvailableConnectionChanged() was called\"))\n\n        connection = newConnection\n        hideSnackbar(SNACKBAR_TAG_CONNECTION_ESTABLISHED)\n        hideSnackbar(SNACKBAR_TAG_SSE_ERROR)\n        hideSnackbar(SNACKBAR_TAG_DEMO_MODE_ACTIVE)\n        serverProperties = null\n        handlePendingAction()\n\n        val wifiManager = applicationContext.getSystemService(Context.WIFI_SERVICE) as WifiManager\n        when {\n            newConnection != null -> {\n                handleConnectionChange()\n                controller.updateConnection(newConnection, null, 0)\n            }\n            failureReason is NoUrlInformationException -> {\n                // Attempt resolving only if we're connected locally and\n                // no local connection is configured yet\n                if (failureReason.wouldHaveUsedLocalConnection() && ConnectionFactory.activeLocalConnection == null) {\n                    if (serviceResolveJob == null) {\n                        val resolver = AsyncServiceResolver(\n                            this,\n                            AsyncServiceResolver.OPENHAB_SERVICE_TYPE,\n                            this\n                        )\n                        serviceResolveJob = launch {\n                            handleServiceResolveResult(resolver.resolve())\n                            serviceResolveJob = null\n                        }\n                        controller.updateConnection(null,\n                            getString(R.string.resolving_openhab),\n                            R.drawable.ic_home_search_outline_grey_340dp)\n                    }\n                } else {\n                    val officialServer = !failureReason.wouldHaveUsedLocalConnection() &&\n                        prefs.getRemoteUrl().matches(\"^(home.)?myopenhab.org$\".toRegex())\n                    controller.indicateMissingConfiguration(false, officialServer)\n                }\n            }\n            failureReason is NetworkNotAvailableException && !wifiManager.isWifiEnabled -> {\n                controller.indicateNoNetwork(getString(R.string.error_wifi_not_available), true)\n            }\n            failureReason is ConnectionNotInitializedException -> {\n                controller.updateConnection(null, null, 0)\n            }\n            else -> {\n                controller.indicateNoNetwork(getString(R.string.error_network_not_available), false)\n                scheduleRetry {\n                    ConnectionFactory.restartNetworkCheck()\n                    recreate()\n                }\n            }\n        }\n\n        viewPool.clear()\n        updateSitemapDrawerEntries()\n        updateDrawerItemVisibility()\n        updateDrawerServerEntries()\n        invalidateOptionsMenu()\n        updateTitle()\n    }\n\n    fun scheduleRetry(runAfterDelay: () -> Unit) {\n        retryJob?.cancel(CancellationException(\"scheduleRetry() was called\"))\n        retryJob = CoroutineScope(Dispatchers.Main + Job()).launch {\n            delay(30 * 1000)\n            Log.d(TAG, \"runAfterDelay()\")\n            runAfterDelay()\n        }\n    }\n\n    override fun onPrimaryConnectionChanged() {\n        // no-op\n    }\n\n    override fun onActiveCloudConnectionChanged(connection: CloudConnection?) {\n        CrashReportingHelper.d(TAG, \"onActiveCloudConnectionChanged()\")\n        updateDrawerItemVisibility()\n        handlePendingAction()\n    }\n\n    override fun onPrimaryCloudConnectionChanged(connection: CloudConnection?) {\n        CrashReportingHelper.d(TAG, \"onPrimaryCloudConnectionChanged()\")\n        handlePendingAction()\n        GlobalScope.launch {\n            showPushNotificationWarningIfNeeded()\n        }\n    }\n\n    /**\n     * Determines whether to switch the server based on the wifi ssid. Returns -1 if no switch is required,\n     * the server id otherwise.\n     */\n    private fun determineServerIdToSwitchToBasedOnWifi(ssid: String?, prevSsid: String?): Int {\n        val anyServerHasSetWifi = prefs\n            .getConfiguredServerIds()\n            .map { id -> ServerConfiguration.load(prefs, getSecretPrefs(), id) }\n            .any { config -> config?.wifiSsid?.isNotEmpty() == true }\n\n        val locationManager = getSystemService(Context.LOCATION_SERVICE) as LocationManager\n        val requiredPermission = when {\n            Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q -> Manifest.permission.ACCESS_FINE_LOCATION\n            Build.VERSION.SDK_INT >= Build.VERSION_CODES.O -> Manifest.permission.ACCESS_COARSE_LOCATION\n            else -> null\n        }\n\n        when {\n            !anyServerHasSetWifi -> {\n                Log.d(TAG, \"Cannot auto select server: No server with configured wifi\")\n                return -1\n            }\n            Build.VERSION.SDK_INT >= Build.VERSION_CODES.O &&\n                !LocationManagerCompat.isLocationEnabled(locationManager) -> {\n                Log.d(TAG, \"Cannot auto select server: Location off\")\n                showSnackbar(\n                    SNACKBAR_TAG_SWITCHED_SERVER,\n                    R.string.settings_multi_server_wifi_ssid_location_off,\n                )\n                return -1\n            }\n            requiredPermission != null && !hasPermissions(arrayOf(requiredPermission)) -> {\n                Log.d(TAG, \"Cannot auto select server: Missing permission $requiredPermission\")\n                showSnackbar(\n                    SNACKBAR_TAG_SWITCHED_SERVER,\n                    R.string.settings_multi_server_wifi_ssid_missing_permissions,\n                    actionResId = R.string.settings_background_tasks_permission_allow\n                ) {\n                    requestPermissionsIfRequired(\n                        arrayOf(requiredPermission),\n                        REQUEST_CODE_PERMISSIONS\n                    )\n                }\n                return -1\n            }\n            ssid == prevSsid -> {\n                Log.d(TAG, \"Cannot auto select server: SSID didn't change since the last check\")\n                return -1\n            }\n            ssid.isNullOrEmpty() -> {\n                Log.d(TAG, \"Cannot auto select server: SSID empty, probably not connected to wifi\")\n                return -1\n            }\n        }\n\n        val serverForCurrentWifi = prefs\n            .getConfiguredServerIds()\n            .map { id -> ServerConfiguration.load(prefs, getSecretPrefs(), id) }\n            .firstOrNull { config -> config?.wifiSsid == ssid }\n            ?: return -1\n\n        val currentActive = prefs.getActiveServerId()\n        if (serverForCurrentWifi.id == currentActive) {\n            Log.d(TAG, \"Server for current wifi already active\")\n            return -1\n        }\n        return serverForCurrentWifi.id\n    }\n\n    private fun switchServerBasedOnWifi(serverId: Int) {\n        val prevActiveServer = prefs.getActiveServerId()\n        val serverForCurrentWifi = ServerConfiguration.load(prefs, getSecretPrefs(), serverId) ?: return\n\n        prefs.edit {\n            putActiveServerId(serverForCurrentWifi.id)\n        }\n        showSnackbar(\n            SNACKBAR_TAG_SWITCHED_SERVER,\n            getString(R.string.settings_multi_server_wifi_ssid_switched, serverForCurrentWifi.name),\n            Snackbar.LENGTH_LONG,\n            R.string.undo\n        ) {\n            prefs.edit {\n                putActiveServerId(prevActiveServer)\n            }\n        }\n    }\n\n    private fun handleConnectionChange() {\n        if (connection is DemoConnection) {\n            showSnackbar(\n                SNACKBAR_TAG_DEMO_MODE_ACTIVE,\n                R.string.info_demo_mode_short,\n                actionResId = R.string.turn_off\n            ) {\n                prefs.edit {\n                    putBoolean(PrefKeys.DEMO_MODE, false)\n                }\n            }\n        } else {\n            val hasLocalAndRemote =\n                ConnectionFactory.activeLocalConnection != null && ConnectionFactory.activeRemoteConnection != null\n            val type = connection?.connectionType\n            if (hasLocalAndRemote && type == Connection.TYPE_LOCAL) {\n                showSnackbar(\n                    SNACKBAR_TAG_CONNECTION_ESTABLISHED,\n                    R.string.info_conn_url,\n                    Snackbar.LENGTH_SHORT\n                )\n            } else if (hasLocalAndRemote && type == Connection.TYPE_REMOTE) {\n                showSnackbar(\n                    SNACKBAR_TAG_CONNECTION_ESTABLISHED,\n                    R.string.info_conn_rem_url,\n                    Snackbar.LENGTH_SHORT\n                )\n            }\n        }\n        queryServerProperties()\n    }\n\n    fun enableWifiAndIndicateStartup() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n            val panelIntent = Intent(Settings.Panel.ACTION_WIFI)\n            startActivity(panelIntent)\n        } else {\n            val wifiManager = applicationContext.getSystemService(Context.WIFI_SERVICE) as WifiManager\n            @Suppress(\"DEPRECATION\")\n            wifiManager.isWifiEnabled = true\n            controller.updateConnection(null, getString(R.string.waiting_for_wifi),\n                R.drawable.ic_wifi_strength_outline_grey_24dp)\n        }\n    }\n\n    fun retryServerPropertyQuery() {\n        controller.clearServerCommunicationFailure()\n        queryServerProperties()\n    }\n\n    override fun doesLockModeRequirePrompt(mode: ScreenLockMode): Boolean {\n        return mode == ScreenLockMode.Enabled\n    }\n\n    private fun queryServerProperties() {\n        propsUpdateHandle?.cancel()\n        retryJob?.cancel(CancellationException(\"queryServerProperties() was called\"))\n        val successCb: (ServerProperties) -> Unit = { props ->\n            serverProperties = props\n            updateSitemapDrawerEntries()\n            if (props.sitemaps.isEmpty()) {\n                Log.e(TAG, \"openHAB returned empty Sitemap list\")\n                controller.indicateServerCommunicationFailure(getString(R.string.error_empty_sitemap_list))\n                scheduleRetry {\n                    retryServerPropertyQuery()\n                }\n            } else {\n                chooseSitemap()\n            }\n            if (connection !is DemoConnection) {\n                prefs.edit {\n                    putInt(PrefKeys.PREV_SERVER_FLAGS, props.flags)\n                }\n            }\n            handlePendingAction()\n        }\n        propsUpdateHandle = ServerProperties.fetch(this, connection!!,\n            successCb, this::handlePropertyFetchFailure)\n        BackgroundTasksManager.triggerPeriodicWork(this)\n    }\n\n    private fun chooseSitemap() {\n        val sitemap = selectConfiguredSitemapFromList()\n        if (sitemap != null) {\n            controller.openSitemap(sitemap)\n        } else {\n            showSitemapSelectionDialog()\n        }\n    }\n\n    private fun handleServiceResolveResult(info: ServiceInfo?) {\n        if (info != null && prefs.getConfiguredServerIds().isEmpty()) {\n            info.addToPrefs(this)\n        } else {\n            Log.d(TAG, \"Failed to discover openHAB server\")\n            controller.indicateMissingConfiguration(resolveAttempted = true, wouldHaveUsedOfficialServer = false)\n        }\n    }\n\n    private fun processIntent(intent: Intent) {\n        Log.d(TAG, \"Got intent: $intent\")\n\n        if (intent.action == Intent.ACTION_MAIN) {\n            intent.action = prefs.getStringOrNull(PrefKeys.START_PAGE)\n        }\n\n        when (intent.action) {\n            NfcAdapter.ACTION_NDEF_DISCOVERED, Intent.ACTION_VIEW -> {\n                val tag = intent.data?.toTagData()\n                BackgroundTasksManager.enqueueNfcUpdateIfNeeded(this, tag)\n\n                val sitemapUrl = tag?.sitemap\n                if (!sitemapUrl.isNullOrEmpty()) {\n                    executeOrStoreAction(PendingAction.OpenSitemapUrl(sitemapUrl, 0))\n                }\n            }\n            ACTION_NOTIFICATION_SELECTED -> {\n                CloudMessagingHelper.onNotificationSelected(this, intent)\n                val notificationId = intent.getStringExtra(EXTRA_PERSISTED_NOTIFICATION_ID).orEmpty()\n                executeActionIfPossible(PendingAction.OpenNotification(notificationId, true))\n            }\n            ACTION_HABPANEL_SELECTED, ACTION_OH3_UI_SELECTED, ACTION_FRONTAIL_SELECTED -> {\n                val serverId = intent.getIntExtra(EXTRA_SERVER_ID, prefs.getActiveServerId())\n                val ui = when (intent.action) {\n                    ACTION_HABPANEL_SELECTED -> WebViewUi.HABPANEL\n                    ACTION_FRONTAIL_SELECTED -> WebViewUi.FRONTAIL\n                    else -> WebViewUi.OH3_UI\n                }\n                val subpage = intent.getStringExtra(EXTRA_SUBPAGE)\n                executeOrStoreAction(PendingAction.OpenWebViewUi(ui, serverId, subpage))\n            }\n            ACTION_VOICE_RECOGNITION_SELECTED -> executeOrStoreAction(PendingAction.LaunchVoiceRecognition())\n            ACTION_SITEMAP_SELECTED -> {\n                val sitemapUrl = intent.getStringExtra(EXTRA_SITEMAP_URL) ?: return\n                val serverId = intent.getIntExtra(EXTRA_SERVER_ID, prefs.getActiveServerId())\n                executeOrStoreAction(PendingAction.OpenSitemapUrl(sitemapUrl, serverId))\n            }\n        }\n    }\n\n    fun triggerPageUpdate(pageUrl: String, forceReload: Boolean) {\n        controller.triggerPageUpdate(pageUrl, forceReload)\n    }\n\n    private fun setupToolbar() {\n        val toolbar = findViewById<Toolbar>(R.id.openhab_toolbar)\n        setSupportActionBar(toolbar)\n        supportActionBar?.setDisplayHomeAsUpEnabled(true)\n        supportActionBar?.setHomeButtonEnabled(true)\n\n        progressBar = toolbar.findViewById(R.id.toolbar_progress_bar)\n        setProgressIndicatorVisible(false)\n    }\n\n    private fun setupDrawer() {\n        drawerLayout = findViewById(R.id.activity_content)\n        drawerToggle = ActionBarDrawerToggle(this, drawerLayout,\n            R.string.drawer_open, R.string.drawer_close)\n        drawerLayout.addDrawerListener(drawerToggle)\n        drawerLayout.addDrawerListener(object : DrawerLayout.SimpleDrawerListener() {\n            override fun onDrawerOpened(drawerView: View) {\n                if (serverProperties != null && propsUpdateHandle == null) {\n                    propsUpdateHandle = ServerProperties.updateSitemaps(this@MainActivity,\n                        serverProperties!!, connection!!,\n                        { props ->\n                            serverProperties = props\n                            updateSitemapDrawerEntries()\n                        },\n                        this@MainActivity::handlePropertyFetchFailure)\n                }\n            }\n            override fun onDrawerClosed(drawerView: View) {\n                super.onDrawerClosed(drawerView)\n                updateDrawerMode(false)\n            }\n        })\n        drawerLayout.setDrawerShadow(R.drawable.drawer_shadow, GravityCompat.START)\n\n        val drawerView = findViewById<NavigationView>(R.id.left_drawer)\n        drawerView.inflateMenu(R.menu.left_drawer)\n        drawerMenu = drawerView.menu\n\n        // We only want to tint the menu icons, but not our loaded sitemap icons. NavigationView\n        // unfortunately doesn't support this directly, so we tint the icon drawables manually\n        // instead of letting NavigationView do it.\n        drawerIconTintList = drawerView.itemIconTintList\n        drawerView.itemIconTintList = null\n        drawerMenu.forEach { item -> item.icon = applyDrawerIconTint(item.icon) }\n\n        drawerView.setNavigationItemSelectedListener { item ->\n            drawerLayout.closeDrawers()\n            var handled = false\n            when (item.itemId) {\n                R.id.notifications -> {\n                    openNotifications(null, false)\n                    handled = true\n                }\n                R.id.nfc -> {\n                    val intent = Intent(this, NfcItemPickerActivity::class.java)\n                    startActivity(intent)\n                    handled = true\n                }\n                R.id.habpanel -> {\n                    openWebViewUi(WebViewUi.HABPANEL, false, null)\n                    handled = true\n                }\n                R.id.oh3_ui -> {\n                    openWebViewUi(WebViewUi.OH3_UI, false, null)\n                    handled = true\n                }\n                R.id.frontail -> {\n                    openWebViewUi(WebViewUi.FRONTAIL, false, null)\n                    handled = true\n                }\n                R.id.settings -> {\n                    val settingsIntent = Intent(this@MainActivity, PreferencesActivity::class.java)\n                    settingsIntent.putExtra(PreferencesActivity.START_EXTRA_SERVER_PROPERTIES, serverProperties)\n                    startActivityForResult(settingsIntent, REQUEST_CODE_SETTINGS)\n                    handled = true\n                }\n                R.id.about -> {\n                    val aboutIntent = Intent(this, AboutActivity::class.java)\n                    aboutIntent.putExtra(\"serverProperties\", serverProperties)\n                    startActivity(aboutIntent)\n                    handled = true\n                }\n                R.id.default_sitemap -> {\n                    val sitemap = serverProperties?.sitemaps?.firstOrNull { s ->\n                        s.name == prefs.getDefaultSitemap(connection)?.name\n                    }\n                    if (sitemap != null) {\n                        controller.openSitemap(sitemap)\n                        handled = true\n                    } else if (prefs.getDefaultSitemap(connection) != null) {\n                        executeOrStoreAction(PendingAction.ChooseSitemap())\n                        handled = true\n                    }\n                }\n            }\n            if (item.groupId == R.id.sitemaps) {\n                val sitemap = serverProperties?.sitemaps?.firstOrNull { s -> s.name.hashCode() == item.itemId }\n                if (sitemap != null) {\n                    controller.openSitemap(sitemap)\n                    handled = true\n                }\n            }\n            if (item.groupId == R.id.servers) {\n                prefs.edit {\n                    putActiveServerId(item.itemId)\n                }\n                updateServerNameInDrawer()\n                // Menu views aren't updated in a click handler, so defer the menu update\n                launch {\n                    updateDrawerMode(false)\n                }\n                handled = true\n            }\n            handled\n        }\n\n        drawerModeSelectorContainer = drawerView.inflateHeaderView(R.layout.drawer_header)\n        drawerModeSelectorContainer.setOnClickListener { updateDrawerMode(!inServerSelectionMode) }\n        drawerModeToggle = drawerModeSelectorContainer.findViewById(R.id.drawer_mode_switcher)\n        drawerServerNameView = drawerModeSelectorContainer.findViewById(R.id.server_name)\n    }\n\n    private fun updateDrawerServerEntries() {\n        // Remove existing items from server group\n        drawerMenu.getGroupItems(R.id.servers)\n            .forEach { item -> drawerMenu.removeItem(item.itemId) }\n\n        // Add new items\n        val configs = prefs.getConfiguredServerIds()\n            .mapNotNull { id -> ServerConfiguration.load(prefs, getSecretPrefs(), id) }\n        configs.forEachIndexed { index, config -> drawerMenu.add(R.id.servers, config.id, index, config.name) }\n\n        if (configs.size > 1 && connection !is DemoConnection) {\n            drawerModeSelectorContainer.isVisible = true\n        } else {\n            drawerModeSelectorContainer.isGone = true\n            inServerSelectionMode = false\n        }\n\n        updateServerNameInDrawer()\n        updateDrawerItemVisibility()\n    }\n\n    private fun updateSitemapDrawerEntries() {\n        val defaultSitemapItem = drawerMenu.findItem(R.id.default_sitemap)\n        val sitemaps = serverProperties?.sitemaps\n            ?.sortedWithDefaultName(prefs.getDefaultSitemap(connection)?.name.orEmpty())\n\n        drawerMenu.getGroupItems(R.id.sitemaps)\n            .filter { item -> item !== defaultSitemapItem }\n            .forEach { item -> drawerMenu.removeItem(item.itemId) }\n\n        if (sitemaps?.isNotEmpty() != true) {\n            return\n        }\n\n        if (prefs.areSitemapsShownInDrawer()) {\n            sitemaps.forEachIndexed { index, sitemap ->\n                val item = drawerMenu.add(R.id.sitemaps, sitemap.name.hashCode(), index, sitemap.label)\n                loadSitemapIcon(sitemap, item)\n            }\n        } else {\n            val sitemap = serverProperties?.sitemaps?.firstOrNull { s ->\n                s.name == prefs.getDefaultSitemap(connection)?.name.orEmpty()\n            }\n            if (sitemap != null) {\n                defaultSitemapItem.title = sitemap.label\n                loadSitemapIcon(sitemap, defaultSitemapItem)\n            } else {\n                defaultSitemapItem.title = getString(R.string.mainmenu_openhab_selectsitemap)\n                defaultSitemapItem.icon =\n                    applyDrawerIconTint(ContextCompat.getDrawable(this, R.drawable.ic_openhab_appicon_24dp))\n            }\n        }\n\n        updateDrawerItemVisibility()\n    }\n\n    private fun updateServerNameInDrawer() {\n        val activeConfig = ServerConfiguration.load(prefs, getSecretPrefs(), prefs.getActiveServerId())\n        drawerServerNameView.text = activeConfig?.name\n    }\n\n    private fun updateDrawerItemVisibility() {\n        val serverItems = drawerMenu.getGroupItems(R.id.servers)\n        drawerMenu.setGroupVisible(R.id.servers, serverItems.size > 1 && inServerSelectionMode)\n\n        if (serverProperties?.sitemaps?.isNotEmpty() == true && !inServerSelectionMode) {\n            drawerMenu.setGroupVisible(R.id.sitemaps, true)\n\n            val defaultSitemapItem = drawerMenu.findItem(R.id.default_sitemap)\n            defaultSitemapItem.isVisible = !prefs.areSitemapsShownInDrawer()\n        } else {\n            drawerMenu.setGroupVisible(R.id.sitemaps, false)\n        }\n\n        if (inServerSelectionMode) {\n            drawerMenu.setGroupVisible(R.id.options, false)\n        } else {\n            drawerMenu.setGroupVisible(R.id.options, true)\n\n            val notificationsItem = drawerMenu.findItem(R.id.notifications)\n            notificationsItem.isVisible = ConnectionFactory.activeCloudConnection?.connection != null\n\n            val habPanelItem = drawerMenu.findItem(R.id.habpanel)\n            habPanelItem.isVisible = serverProperties?.hasWebViewUiInstalled(WebViewUi.HABPANEL) == true &&\n                prefs.getBoolean(PrefKeys.DRAWER_ENTRY_HABPANEL, true)\n            manageHabPanelShortcut(serverProperties?.hasWebViewUiInstalled(WebViewUi.HABPANEL) == true)\n\n            val oh3UiItem = drawerMenu.findItem(R.id.oh3_ui)\n            oh3UiItem.isVisible = serverProperties?.hasWebViewUiInstalled(WebViewUi.OH3_UI) == true &&\n                prefs.getBoolean(PrefKeys.DRAWER_ENTRY_OH3_UI, true)\n\n            val frontailItem = drawerMenu.findItem(R.id.frontail)\n            frontailItem.isVisible = serverProperties != null &&\n                connection?.connectionType == Connection.TYPE_LOCAL &&\n                prefs.getBoolean(PrefKeys.DRAWER_ENTRY_FRONTAIL, false)\n\n            val nfcItem = drawerMenu.findItem(R.id.nfc)\n            nfcItem.isVisible = serverProperties != null &&\n                (NfcAdapter.getDefaultAdapter(this) != null || Util.isEmulator()) &&\n                prefs.getPrimaryServerId() == prefs.getActiveServerId() &&\n                prefs.getBoolean(PrefKeys.DRAWER_ENTRY_NFC, true)\n        }\n    }\n\n    private fun updateDrawerMode(inServerMode: Boolean) {\n        if (inServerMode == inServerSelectionMode) {\n            return\n        }\n        inServerSelectionMode = inServerMode\n        drawerModeToggle.setImageResource(\n            if (inServerSelectionMode) R.drawable.ic_menu_up_24dp else R.drawable.ic_menu_down_24dp\n        )\n        updateDrawerItemVisibility()\n    }\n\n    private fun loadSitemapIcon(sitemap: Sitemap, item: MenuItem) {\n        val defaultIcon = ContextCompat.getDrawable(this, R.drawable.ic_openhab_appicon_24dp)\n        item.icon = applyDrawerIconTint(defaultIcon)\n        val conn = connection\n\n        if (sitemap.icon == null || conn == null) {\n            return\n        }\n        launch {\n            try {\n                item.icon = conn.httpClient.get(\n                    sitemap.icon.toUrl(this@MainActivity, determineDataUsagePolicy().loadIconsWithState)\n                )\n                    .asBitmap(defaultIcon!!.intrinsicWidth, ImageConversionPolicy.ForceTargetSize)\n                    .response\n                    .toDrawable(resources)\n            } catch (e: HttpClient.HttpException) {\n                Log.w(TAG, \"Could not fetch icon for sitemap ${sitemap.name}\")\n            }\n        }\n    }\n\n    private fun applyDrawerIconTint(icon: Drawable?): Drawable? {\n        if (icon == null) {\n            return null\n        }\n        val wrapped = DrawableCompat.wrap(icon.mutate())\n        DrawableCompat.setTintList(wrapped, drawerIconTintList)\n        return wrapped\n    }\n\n    private fun executeOrStoreAction(action: PendingAction) {\n        if (!executeActionIfPossible(action)) {\n            pendingAction = action\n        }\n    }\n\n    private fun handlePendingAction() {\n        val action = pendingAction\n        if (action != null && executeActionIfPossible(action)) {\n            pendingAction = null\n        }\n    }\n\n    private fun executeActionIfPossible(action: PendingAction): Boolean = when {\n        action is PendingAction.ChooseSitemap && isStarted -> {\n            chooseSitemap()\n            true\n        }\n        action is PendingAction.OpenSitemapUrl && isStarted && serverProperties != null -> {\n            executeActionForServer(action.serverId) { buildUrlAndOpenSitemap(action.url) }\n        }\n        action is PendingAction.OpenWebViewUi && isStarted &&\n            serverProperties?.hasWebViewUiInstalled(action.ui) == true -> {\n            executeActionForServer(action.serverId) { openWebViewUi(action.ui, true, action.subpage) }\n        }\n        action is PendingAction.LaunchVoiceRecognition && serverProperties != null -> {\n            launchVoiceRecognition()\n            true\n        }\n        action is PendingAction.OpenNotification && isStarted -> {\n            val conn = if (action.primary) {\n                ConnectionFactory.primaryCloudConnection\n            } else {\n                ConnectionFactory.activeCloudConnection\n            }\n            if (conn?.connection != null) {\n                openNotifications(action.notificationId, action.primary)\n                true\n            } else {\n                false\n            }\n        }\n        else -> false\n    }\n\n    private fun executeActionForServer(serverId: Int, action: () -> Unit): Boolean = when {\n        serverId !in prefs.getConfiguredServerIds() -> {\n            showSnackbar(\n                SNACKBAR_TAG_SERVER_MISSING,\n                R.string.home_shortcut_server_has_been_deleted\n            )\n            true\n        }\n        serverId != prefs.getActiveServerId() -> {\n            prefs.edit {\n                putActiveServerId(serverId)\n            }\n            updateDrawerServerEntries()\n            false\n        }\n        else -> {\n            action()\n            true\n        }\n    }\n\n    private fun selectConfiguredSitemapFromList(): Sitemap? {\n        val configuredSitemap = prefs.getDefaultSitemap(connection)?.name.orEmpty()\n        val sitemaps = serverProperties?.sitemaps\n        val result = when {\n            sitemaps == null -> null\n            // We only have one sitemap, use it\n            sitemaps.size == 1 -> sitemaps[0]\n            // Select configured sitemap if still present, nothing otherwise\n            configuredSitemap.isNotEmpty() -> sitemaps.firstOrNull { sitemap -> sitemap.name == configuredSitemap }\n            // Nothing configured -> can't auto-select anything\n            else -> null\n        }\n\n        Log.d(TAG, \"Configured sitemap is '$configuredSitemap', selected $result\")\n        if (result == null && configuredSitemap.isNotEmpty()) {\n            // clear old configuration\n            prefs.updateDefaultSitemap(connection, null)\n        } else if (result != null && (configuredSitemap.isEmpty() || configuredSitemap != result.name)) {\n            // update result\n            prefs.updateDefaultSitemap(connection, result)\n            updateSitemapDrawerEntries()\n        }\n\n        return result\n    }\n\n    private fun showSitemapSelectionDialog() {\n        Log.d(TAG, \"Opening sitemap selection dialog\")\n        if (sitemapSelectionDialog?.isShowing == true) {\n            sitemapSelectionDialog?.dismiss()\n        }\n        val sitemaps = serverProperties?.sitemaps\n        if (isFinishing || sitemaps == null) {\n            return\n        }\n        val sitemapLabels = sitemaps.map { s -> s.label }.toTypedArray()\n        sitemapSelectionDialog = AlertDialog.Builder(this)\n            .setTitle(R.string.mainmenu_openhab_selectsitemap)\n            .setItems(sitemapLabels) { _, which ->\n                val sitemap = sitemaps[which]\n                Log.d(TAG, \"Selected sitemap $sitemap\")\n                prefs.updateDefaultSitemap(connection, sitemap)\n                controller.openSitemap(sitemap)\n                updateSitemapDrawerEntries()\n            }\n            .show()\n    }\n\n    private fun openNotifications(highlightedId: String?, primaryServer: Boolean) {\n        controller.openNotifications(highlightedId, primaryServer)\n        drawerToggle.isDrawerIndicatorEnabled = false\n    }\n\n    private fun openWebViewUi(ui: WebViewUi, isStackRoot: Boolean, subpage: String?) {\n        hideSnackbar(SNACKBAR_TAG_SSE_ERROR)\n        controller.showWebViewUi(ui, isStackRoot, subpage)\n        drawerToggle.isDrawerIndicatorEnabled = isStackRoot\n    }\n\n    private fun buildUrlAndOpenSitemap(partUrl: String) {\n        controller.openPage(\"rest/sitemaps$partUrl\")\n    }\n\n    fun onWidgetSelected(linkedPage: LinkedPage, source: WidgetListFragment) {\n        Log.d(TAG, \"Got widget link = ${linkedPage.link}\")\n        controller.openPage(linkedPage, source)\n    }\n\n    fun updateTitle() {\n        val title = controller.currentTitle\n        setTitle(title ?: getString(R.string.app_name))\n        drawerToggle.isDrawerIndicatorEnabled = !controller.canGoBack()\n    }\n\n    fun setProgressIndicatorVisible(visible: Boolean) {\n        if (visible) {\n            progressBar?.show()\n        } else {\n            progressBar?.hide()\n        }\n    }\n\n    private fun launchVoiceRecognition() {\n        val speechIntent = BackgroundTasksManager.buildVoiceRecognitionIntent(this, false)\n        try {\n            startActivity(speechIntent)\n        } catch (e: ActivityNotFoundException) {\n            showSnackbar(\n                SNACKBAR_TAG_NO_VOICE_RECOGNITION_INSTALLED,\n                R.string.error_no_speech_to_text_app_found,\n                actionResId = R.string.install\n            ) {\n                openInAppStore(\"com.google.android.googlequicksearchbox\")\n            }\n        }\n    }\n\n    private suspend fun showPushNotificationWarningIfNeeded() {\n        val status = CloudMessagingHelper.getPushNotificationStatus(this@MainActivity)\n        if (status.notifyUser) {\n            showSnackbar(SNACKBAR_TAG_PUSH_NOTIFICATION_FAIL, status.message)\n        }\n    }\n\n    fun showRefreshHintSnackbarIfNeeded() {\n        if (prefs.getBoolean(PrefKeys.SWIPE_REFRESH_EXPLAINED, false)) {\n            return\n        }\n\n        showSnackbar(\n            SNACKBAR_TAG_NO_MANUAL_REFRESH_REQUIRED,\n            R.string.swipe_to_refresh_description,\n            actionResId = R.string.got_it\n        ) {\n            prefs.edit {\n                putBoolean(PrefKeys.SWIPE_REFRESH_EXPLAINED, true)\n            }\n        }\n    }\n\n    fun showDataSaverHintSnackbarIfNeeded() {\n        if (prefs.getBoolean(PrefKeys.DATA_SAVER_EXPLAINED, false) ||\n            determineDataUsagePolicy().loadIconsWithState\n        ) {\n            return\n        }\n\n        showSnackbar(\n            SNACKBAR_TAG_DATA_SAVER_ON,\n            R.string.data_saver_snackbar,\n            actionResId = R.string.got_it\n        ) {\n            prefs.edit {\n                putBoolean(PrefKeys.DATA_SAVER_EXPLAINED, true)\n            }\n        }\n    }\n\n    fun setDrawerLocked(locked: Boolean) {\n        drawerLayout.isSwipeDisabled = locked\n    }\n\n    private fun handlePropertyFetchFailure(request: Request, statusCode: Int, error: Throwable) {\n        Log.e(TAG, \"Error: $error\", error)\n        Log.e(TAG, \"HTTP status code: $statusCode\")\n        var message = getHumanReadableErrorMessage(request.url.toString(), statusCode, error, false)\n        if (prefs.isDebugModeEnabled()) {\n            message = SpannableStringBuilder(message).apply {\n                inSpans(RelativeSizeSpan(0.8f)) {\n                    append(\"\\n\\nURL: \").append(request.url.toString())\n\n                    val authHeader = request.header(\"Authorization\")\n                    if (authHeader?.startsWith(\"Basic\") == true) {\n                        val base64Credentials = authHeader.substring(\"Basic\".length).trim()\n                        val credentials = String(Base64.decode(base64Credentials, Base64.DEFAULT),\n                            Charset.forName(\"UTF-8\"))\n                        append(\"\\nUsername: \")\n                        append(credentials.substring(0, credentials.indexOf(\":\")))\n                    }\n\n                    append(\"\\nException stack:\\n\")\n                }\n\n                inSpans(RelativeSizeSpan(0.6f)) {\n                    var origError: Throwable?\n                    var cause: Throwable? = error\n                    do {\n                        append(cause?.toString()).append('\\n')\n                        origError = cause\n                        cause = origError?.cause\n                    } while (cause != null && origError !== cause)\n                }\n            }\n        }\n\n        controller.indicateServerCommunicationFailure(message)\n        scheduleRetry {\n            retryServerPropertyQuery()\n        }\n        propsUpdateHandle = null\n    }\n\n    private fun showMissingPermissionsWarningIfNeeded() {\n        val missingPermissions = BackgroundTasksManager.KNOWN_KEYS\n            .filter { entry ->\n                val requiredPermissions = BackgroundTasksManager.getRequiredPermissionsForTask(entry)\n                prefs.getStringOrNull(entry)?.toItemUpdatePrefValue()?.first == true &&\n                    requiredPermissions != null && !hasPermissions(requiredPermissions)\n            }\n            .mapNotNull { entry -> BackgroundTasksManager.getRequiredPermissionsForTask(entry)?.toList() }\n            .flatten()\n            .toSet()\n            .filter { !hasPermissions(arrayOf(it)) }\n            .toMutableList()\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R &&\n            missingPermissions.contains(Manifest.permission.ACCESS_BACKGROUND_LOCATION)\n        ) {\n            if (missingPermissions.size > 1) {\n                Log.d(TAG, \"Remove background location from permissions to request\")\n                missingPermissions.remove(Manifest.permission.ACCESS_BACKGROUND_LOCATION)\n            } else {\n                showSnackbar(\n                    SNACKBAR_TAG_BG_TASKS_MISSING_PERMISSION_LOCATION,\n                    getString(\n                        R.string.settings_background_tasks_permission_denied_background_location,\n                        packageManager.backgroundPermissionOptionLabel\n                    ),\n                    actionResId = android.R.string.ok\n                ) {\n                    Intent(Settings.ACTION_APPLICATION_SETTINGS).apply {\n                        putExtra(Settings.EXTRA_APP_PACKAGE, BuildConfig.APPLICATION_ID)\n                        startActivity(this)\n                    }\n                }\n                return\n            }\n        }\n\n        if (missingPermissions.isNotEmpty()) {\n            Log.d(TAG, \"At least one permission for background tasks has been denied\")\n            showSnackbar(\n                SNACKBAR_TAG_BG_TASKS_MISSING_PERMISSIONS,\n                R.string.settings_background_tasks_permission_denied,\n                actionResId = R.string.settings_background_tasks_permission_allow\n            ) {\n                requestPermissionsIfRequired(\n                    missingPermissions.toTypedArray(),\n                    REQUEST_CODE_PERMISSIONS\n                )\n            }\n        }\n    }\n\n    private fun manageHabPanelShortcut(visible: Boolean) {\n        manageShortcut(visible, \"habpanel\", ACTION_HABPANEL_SELECTED,\n            R.string.mainmenu_openhab_habpanel, R.mipmap.ic_shortcut_habpanel,\n            R.string.app_shortcut_disabled_habpanel)\n    }\n\n    private fun manageNotificationShortcut(visible: Boolean) {\n        manageShortcut(visible, \"notification\", ACTION_NOTIFICATION_SELECTED,\n            R.string.app_notifications, R.mipmap.ic_shortcut_notifications,\n            R.string.app_shortcut_disabled_notifications)\n    }\n\n    private fun manageVoiceRecognitionShortcut(visible: Boolean) {\n        manageShortcut(visible, \"voice_recognition\", ACTION_VOICE_RECOGNITION_SELECTED,\n            R.string.mainmenu_openhab_voice_recognition,\n            R.mipmap.ic_shortcut_voice_recognition,\n            R.string.app_shortcut_disabled_voice_recognition)\n    }\n\n    private fun manageShortcut(\n        visible: Boolean,\n        id: String,\n        action: String,\n        @StringRes shortLabel: Int,\n        @DrawableRes icon: Int,\n        @StringRes disableMessage: Int\n    ) {\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.N_MR1) {\n            return\n        }\n        if (visible) {\n            val intent = Intent(this, MainActivity::class.java)\n                .setAction(action)\n            val shortcut = ShortcutInfo.Builder(this, id)\n                .setShortLabel(getString(shortLabel))\n                .setIcon(Icon.createWithResource(this, icon))\n                .setIntent(intent)\n                .build()\n            try {\n                shortcutManager?.addDynamicShortcuts(listOf(shortcut))\n            } catch (e: IllegalArgumentException) {\n                Log.e(TAG, \"Failed to add shortcut $id\", e)\n            }\n        } else {\n            shortcutManager?.disableShortcuts(listOf(id), getString(disableMessage))\n        }\n    }\n\n    private fun setVoiceWidgetComponentEnabledSetting(component: Class<*>, isSpeechRecognizerAvailable: Boolean) {\n        val voiceWidget = ComponentName(this, component)\n        val newState = if (isSpeechRecognizerAvailable)\n            PackageManager.COMPONENT_ENABLED_STATE_ENABLED\n        else\n            PackageManager.COMPONENT_ENABLED_STATE_DISABLED\n        packageManager.setComponentEnabledSetting(voiceWidget, newState, PackageManager.DONT_KILL_APP)\n    }\n\n    private sealed class PendingAction {\n        class ChooseSitemap : PendingAction()\n        class OpenSitemapUrl constructor(val url: String, val serverId: Int) : PendingAction()\n        class OpenWebViewUi constructor(val ui: WebViewUi, val serverId: Int, val subpage: String?) : PendingAction()\n        class LaunchVoiceRecognition : PendingAction()\n        class OpenNotification constructor(val notificationId: String, val primary: Boolean) : PendingAction()\n    }\n\n    companion object {\n        const val ACTION_NOTIFICATION_SELECTED = \"org.openhab.habdroid.action.NOTIFICATION_SELECTED\"\n        const val ACTION_HABPANEL_SELECTED = \"org.openhab.habdroid.action.HABPANEL_SELECTED\"\n        const val ACTION_OH3_UI_SELECTED = \"org.openhab.habdroid.action.OH3_UI_SELECTED\"\n        const val ACTION_FRONTAIL_SELECTED = \"org.openhab.habdroid.action.FRONTAIL\"\n        const val ACTION_VOICE_RECOGNITION_SELECTED = \"org.openhab.habdroid.action.VOICE_SELECTED\"\n        const val ACTION_SITEMAP_SELECTED = \"org.openhab.habdroid.action.SITEMAP_SELECTED\"\n        const val EXTRA_SITEMAP_URL = \"sitemapUrl\"\n        const val EXTRA_SERVER_ID = \"serverId\"\n        const val EXTRA_SUBPAGE = \"subpage\"\n        const val EXTRA_PERSISTED_NOTIFICATION_ID = \"persistedNotificationId\"\n\n        const val SNACKBAR_TAG_DEMO_MODE_ACTIVE = \"demoModeActive\"\n        const val SNACKBAR_TAG_PRESS_AGAIN_EXIT = \"pressAgainToExit\"\n        const val SNACKBAR_TAG_CONNECTION_ESTABLISHED = \"connectionEstablished\"\n        const val SNACKBAR_TAG_PUSH_NOTIFICATION_FAIL = \"pushNotificationFail\"\n        const val SNACKBAR_TAG_DATA_SAVER_ON = \"dataSaverOn\"\n        const val SNACKBAR_TAG_NO_VOICE_RECOGNITION_INSTALLED = \"noVoiceRecognitionInstalled\"\n        const val SNACKBAR_TAG_NO_MANUAL_REFRESH_REQUIRED = \"noManualRefreshRequired\"\n        const val SNACKBAR_TAG_BG_TASKS_MISSING_PERMISSIONS = \"bgTasksMissingPermissions\"\n        const val SNACKBAR_TAG_BG_TASKS_MISSING_PERMISSION_LOCATION = \"bgTasksMissingPermissionLocation\"\n        const val SNACKBAR_TAG_SSE_ERROR = \"sseError\"\n        const val SNACKBAR_TAG_SHORTCUT_INFO = \"shortcutInfo\"\n        const val SNACKBAR_TAG_SERVER_MISSING = \"serverMissing\"\n        const val SNACKBAR_TAG_SWITCHED_SERVER = \"switchedServer\"\n\n        private const val STATE_KEY_SERVER_PROPERTIES = \"serverProperties\"\n        private const val STATE_KEY_SITEMAP_SELECTION_SHOWN = \"isSitemapSelectionDialogShown\"\n        private const val STATE_KEY_CONTROLLER_NAME = \"controller\"\n        private const val STATE_KEY_CONNECTION_HASH = \"connectionHash\"\n\n        private val TAG = MainActivity::class.java.simpleName\n\n        // Activities request codes\n        private const val REQUEST_CODE_SETTINGS = 1001\n        private const val REQUEST_CODE_PERMISSIONS = 1002\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mobile/src/main/java/org/openhab/habdroid/ui/MainActivity.kt b/mobile/src/main/java/org/openhab/habdroid/ui/MainActivity.kt
--- a/mobile/src/main/java/org/openhab/habdroid/ui/MainActivity.kt	(revision 4ac3c50a77bd4b1db4af909367d086e256c96773)
+++ b/mobile/src/main/java/org/openhab/habdroid/ui/MainActivity.kt	(date 1632155866653)
@@ -516,7 +516,7 @@
     fun scheduleRetry(runAfterDelay: () -> Unit) {
         retryJob?.cancel(CancellationException("scheduleRetry() was called"))
         retryJob = CoroutineScope(Dispatchers.Main + Job()).launch {
-            delay(30 * 1000)
+            delay(30000)
             Log.d(TAG, "runAfterDelay()")
             runAfterDelay()
         }
Index: .idea/codeStyles/Project.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><component name=\"ProjectCodeStyleConfiguration\">\n  <code_scheme name=\"Project\" version=\"173\">\n    <JetCodeStyleSettings>\n      <option name=\"PACKAGES_TO_USE_STAR_IMPORTS\">\n        <value>\n          <package name=\"kotlinx.android.synthetic\" withSubpackages=\"true\" static=\"false\" />\n        </value>\n      </option>\n      <option name=\"PACKAGES_IMPORT_LAYOUT\">\n        <value>\n          <package name=\"\" alias=\"false\" withSubpackages=\"true\" />\n          <package name=\"\" alias=\"true\" withSubpackages=\"true\" />\n        </value>\n      </option>\n      <option name=\"NAME_COUNT_TO_USE_STAR_IMPORT\" value=\"2147483647\" />\n      <option name=\"NAME_COUNT_TO_USE_STAR_IMPORT_FOR_MEMBERS\" value=\"2147483647\" />\n      <option name=\"CODE_STYLE_DEFAULTS\" value=\"KOTLIN_OFFICIAL\" />\n    </JetCodeStyleSettings>\n    <codeStyleSettings language=\"XML\">\n      <indentOptions>\n        <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n      </indentOptions>\n      <arrangement>\n        <rules>\n          <section>\n            <rule>\n              <match>\n                <AND>\n                  <NAME>xmlns:android</NAME>\n                  <XML_ATTRIBUTE />\n                  <XML_NAMESPACE>^$</XML_NAMESPACE>\n                </AND>\n              </match>\n            </rule>\n          </section>\n          <section>\n            <rule>\n              <match>\n                <AND>\n                  <NAME>xmlns:.*</NAME>\n                  <XML_ATTRIBUTE />\n                  <XML_NAMESPACE>^$</XML_NAMESPACE>\n                </AND>\n              </match>\n              <order>BY_NAME</order>\n            </rule>\n          </section>\n          <section>\n            <rule>\n              <match>\n                <AND>\n                  <NAME>.*:id</NAME>\n                  <XML_ATTRIBUTE />\n                  <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n                </AND>\n              </match>\n            </rule>\n          </section>\n          <section>\n            <rule>\n              <match>\n                <AND>\n                  <NAME>.*:name</NAME>\n                  <XML_ATTRIBUTE />\n                  <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n                </AND>\n              </match>\n            </rule>\n          </section>\n          <section>\n            <rule>\n              <match>\n                <AND>\n                  <NAME>name</NAME>\n                  <XML_ATTRIBUTE />\n                  <XML_NAMESPACE>^$</XML_NAMESPACE>\n                </AND>\n              </match>\n            </rule>\n          </section>\n          <section>\n            <rule>\n              <match>\n                <AND>\n                  <NAME>style</NAME>\n                  <XML_ATTRIBUTE />\n                  <XML_NAMESPACE>^$</XML_NAMESPACE>\n                </AND>\n              </match>\n            </rule>\n          </section>\n          <section>\n            <rule>\n              <match>\n                <AND>\n                  <NAME>.*</NAME>\n                  <XML_ATTRIBUTE />\n                  <XML_NAMESPACE>^$</XML_NAMESPACE>\n                </AND>\n              </match>\n              <order>BY_NAME</order>\n            </rule>\n          </section>\n          <section>\n            <rule>\n              <match>\n                <AND>\n                  <NAME>.*</NAME>\n                  <XML_ATTRIBUTE />\n                  <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>\n                </AND>\n              </match>\n              <order>ANDROID_ATTRIBUTE_ORDER</order>\n            </rule>\n          </section>\n          <section>\n            <rule>\n              <match>\n                <AND>\n                  <NAME>.*</NAME>\n                  <XML_ATTRIBUTE />\n                  <XML_NAMESPACE>.*</XML_NAMESPACE>\n                </AND>\n              </match>\n              <order>BY_NAME</order>\n            </rule>\n          </section>\n        </rules>\n      </arrangement>\n    </codeStyleSettings>\n    <codeStyleSettings language=\"kotlin\">\n      <option name=\"CODE_STYLE_DEFAULTS\" value=\"KOTLIN_OFFICIAL\" />\n      <option name=\"LINE_COMMENT_AT_FIRST_COLUMN\" value=\"false\" />\n      <option name=\"LINE_COMMENT_ADD_SPACE\" value=\"true\" />\n      <option name=\"KEEP_BLANK_LINES_IN_DECLARATIONS\" value=\"1\" />\n      <option name=\"KEEP_BLANK_LINES_IN_CODE\" value=\"1\" />\n      <option name=\"KEEP_BLANK_LINES_BEFORE_RBRACE\" value=\"0\" />\n      <option name=\"ALIGN_MULTILINE_PARAMETERS\" value=\"false\" />\n      <indentOptions>\n        <option name=\"CONTINUATION_INDENT_SIZE\" value=\"4\" />\n      </indentOptions>\n    </codeStyleSettings>\n  </code_scheme>\n</component>\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/codeStyles/Project.xml b/.idea/codeStyles/Project.xml
--- a/.idea/codeStyles/Project.xml	(revision 4ac3c50a77bd4b1db4af909367d086e256c96773)
+++ b/.idea/codeStyles/Project.xml	(date 1632155866680)
@@ -6,12 +6,6 @@
           <package name="kotlinx.android.synthetic" withSubpackages="true" static="false" />
         </value>
       </option>
-      <option name="PACKAGES_IMPORT_LAYOUT">
-        <value>
-          <package name="" alias="false" withSubpackages="true" />
-          <package name="" alias="true" withSubpackages="true" />
-        </value>
-      </option>
       <option name="NAME_COUNT_TO_USE_STAR_IMPORT" value="2147483647" />
       <option name="NAME_COUNT_TO_USE_STAR_IMPORT_FOR_MEMBERS" value="2147483647" />
       <option name="CODE_STYLE_DEFAULTS" value="KOTLIN_OFFICIAL" />
Index: mobile/google-services.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\n  \"project_info\": {\n    \"project_number\": \"849058498762\",\n    \"firebase_url\": \"https://openhab-mobile.firebaseio.com\",\n    \"project_id\": \"openhab-mobile\",\n    \"storage_bucket\": \"openhab-mobile.appspot.com\"\n  },\n  \"client\": [\n    {\n      \"client_info\": {\n        \"mobilesdk_app_id\": \"1:849058498762:android:9fcb28f91e1b4abb\",\n        \"android_client_info\": {\n          \"package_name\": \"org.openhab.habdroid\"\n        }\n      },\n      \"oauth_client\": [\n        {\n          \"client_id\": \"849058498762-079qmadgd5f5hkdve7lkrbubfi842afj.apps.googleusercontent.com\",\n          \"client_type\": 1,\n          \"android_info\": {\n            \"package_name\": \"org.openhab.habdroid\",\n            \"certificate_hash\": \"28e3a41b7c84483ded3df7b8fc2789b5c912badd\"\n          }\n        },\n        {\n          \"client_id\": \"849058498762-bc6nbdk0aercq1e5utj1so77e390cr5j.apps.googleusercontent.com\",\n          \"client_type\": 3\n        }\n      ],\n      \"api_key\": [\n        {\n          \"current_key\": \"AIzaSyBtollIxWyEIm3ni68CaoDJgZuUqoYC2Zw\"\n        }\n      ],\n      \"services\": {\n        \"appinvite_service\": {\n          \"other_platform_oauth_client\": [\n            {\n              \"client_id\": \"849058498762-bc6nbdk0aercq1e5utj1so77e390cr5j.apps.googleusercontent.com\",\n              \"client_type\": 3\n            },\n            {\n              \"client_id\": \"849058498762-3m681ei7b78ajqt9gmvt2gumah724v7q.apps.googleusercontent.com\",\n              \"client_type\": 2,\n              \"ios_info\": {\n                \"bundle_id\": \"es.spaphone.openhab\",\n                \"app_store_id\": \"492054521\"\n              }\n            }\n          ]\n        }\n      }\n    },\n    {\n      \"client_info\": {\n        \"mobilesdk_app_id\": \"1:849058498762:android:1e73d9e722953c8b\",\n        \"android_client_info\": {\n          \"package_name\": \"org.openhab.habdroid.beta\"\n        }\n      },\n      \"oauth_client\": [\n        {\n          \"client_id\": \"849058498762-b49s5qfketdcojkrue5mo1geh0k5q4pm.apps.googleusercontent.com\",\n          \"client_type\": 1,\n          \"android_info\": {\n            \"package_name\": \"org.openhab.habdroid.beta\",\n            \"certificate_hash\": \"28e3a41b7c84483ded3df7b8fc2789b5c912badd\"\n          }\n        },\n        {\n          \"client_id\": \"849058498762-bc6nbdk0aercq1e5utj1so77e390cr5j.apps.googleusercontent.com\",\n          \"client_type\": 3\n        }\n      ],\n      \"api_key\": [\n        {\n          \"current_key\": \"AIzaSyBtollIxWyEIm3ni68CaoDJgZuUqoYC2Zw\"\n        }\n      ],\n      \"services\": {\n        \"appinvite_service\": {\n          \"other_platform_oauth_client\": [\n            {\n              \"client_id\": \"849058498762-bc6nbdk0aercq1e5utj1so77e390cr5j.apps.googleusercontent.com\",\n              \"client_type\": 3\n            },\n            {\n              \"client_id\": \"849058498762-3m681ei7b78ajqt9gmvt2gumah724v7q.apps.googleusercontent.com\",\n              \"client_type\": 2,\n              \"ios_info\": {\n                \"bundle_id\": \"es.spaphone.openhab\",\n                \"app_store_id\": \"492054521\"\n              }\n            }\n          ]\n        }\n      }\n    }\n  ],\n  \"configuration_version\": \"1\"\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/mobile/google-services.json b/mobile/google-services.json
--- a/mobile/google-services.json	(revision 4ac3c50a77bd4b1db4af909367d086e256c96773)
+++ b/mobile/google-services.json	(date 1632155866685)
@@ -1,101 +1,85 @@
 {
-  "project_info": {
-    "project_number": "849058498762",
-    "firebase_url": "https://openhab-mobile.firebaseio.com",
-    "project_id": "openhab-mobile",
-    "storage_bucket": "openhab-mobile.appspot.com"
-  },
-  "client": [
-    {
-      "client_info": {
-        "mobilesdk_app_id": "1:849058498762:android:9fcb28f91e1b4abb",
-        "android_client_info": {
-          "package_name": "org.openhab.habdroid"
-        }
-      },
-      "oauth_client": [
-        {
-          "client_id": "849058498762-079qmadgd5f5hkdve7lkrbubfi842afj.apps.googleusercontent.com",
-          "client_type": 1,
-          "android_info": {
-            "package_name": "org.openhab.habdroid",
-            "certificate_hash": "28e3a41b7c84483ded3df7b8fc2789b5c912badd"
-          }
-        },
-        {
-          "client_id": "849058498762-bc6nbdk0aercq1e5utj1so77e390cr5j.apps.googleusercontent.com",
-          "client_type": 3
-        }
-      ],
-      "api_key": [
-        {
-          "current_key": "AIzaSyBtollIxWyEIm3ni68CaoDJgZuUqoYC2Zw"
-        }
-      ],
-      "services": {
-        "appinvite_service": {
-          "other_platform_oauth_client": [
-            {
-              "client_id": "849058498762-bc6nbdk0aercq1e5utj1so77e390cr5j.apps.googleusercontent.com",
-              "client_type": 3
-            },
-            {
-              "client_id": "849058498762-3m681ei7b78ajqt9gmvt2gumah724v7q.apps.googleusercontent.com",
-              "client_type": 2,
-              "ios_info": {
-                "bundle_id": "es.spaphone.openhab",
-                "app_store_id": "492054521"
-              }
-            }
-          ]
-        }
-      }
-    },
-    {
-      "client_info": {
-        "mobilesdk_app_id": "1:849058498762:android:1e73d9e722953c8b",
-        "android_client_info": {
-          "package_name": "org.openhab.habdroid.beta"
-        }
-      },
-      "oauth_client": [
-        {
-          "client_id": "849058498762-b49s5qfketdcojkrue5mo1geh0k5q4pm.apps.googleusercontent.com",
-          "client_type": 1,
-          "android_info": {
-            "package_name": "org.openhab.habdroid.beta",
-            "certificate_hash": "28e3a41b7c84483ded3df7b8fc2789b5c912badd"
-          }
-        },
-        {
-          "client_id": "849058498762-bc6nbdk0aercq1e5utj1so77e390cr5j.apps.googleusercontent.com",
-          "client_type": 3
-        }
-      ],
-      "api_key": [
-        {
-          "current_key": "AIzaSyBtollIxWyEIm3ni68CaoDJgZuUqoYC2Zw"
-        }
-      ],
-      "services": {
-        "appinvite_service": {
-          "other_platform_oauth_client": [
-            {
-              "client_id": "849058498762-bc6nbdk0aercq1e5utj1so77e390cr5j.apps.googleusercontent.com",
-              "client_type": 3
-            },
-            {
-              "client_id": "849058498762-3m681ei7b78ajqt9gmvt2gumah724v7q.apps.googleusercontent.com",
-              "client_type": 2,
-              "ios_info": {
-                "bundle_id": "es.spaphone.openhab",
-                "app_store_id": "492054521"
-              }
-            }
-          ]
-        }
-      }
-    }
-  ],
-  "configuration_version": "1"
-}
\ No newline at end of file
+    "project_info": {
+        "project_number": "392859643791",
+        "firebase_url": "https://moost-2beab.firebaseio.com",
+        "project_id": "moost-2beab",
+        "storage_bucket": "moost-2beab.appspot.com"
+    },
+    "client": [
+        {
+            "client_info": {
+                "mobilesdk_app_id": "1:392859643791:android:c9be7a0f63768458",
+                "android_client_info": {
+                    "package_name": "io.moost.android.moost"
+                }
+            },
+            "oauth_client": [
+                {
+                    "client_id": "392859643791-asijlr9plbi8tn96ok312jmii5air8jo.apps.googleusercontent.com",
+                    "client_type": 1,
+                    "android_info": {
+                        "package_name": "io.moost.android.moost",
+                        "certificate_hash": "57921ff36b4a5a607c6a1c4cb77d2f758b3e0bf2"
+                    }
+                },
+                {
+                    "client_id": "392859643791-fols8rbs8ipftfngv2rqs4arutok8i22.apps.googleusercontent.com",
+                    "client_type": 1,
+                    "android_info": {
+                        "package_name": "io.moost.android.moost",
+                        "certificate_hash": "94d1cc22d195a764c1c772086746718c7465c0ce"
+                    }
+                },
+                {
+                    "client_id": "392859643791-65p2e60gfj0ej58tatou54l4p98e03vk.apps.googleusercontent.com",
+                    "client_type": 3
+                }
+            ],
+            "api_key": [
+                {
+                    "current_key": "AIzaSyAiBGW02vum3AMZBJx_1TA__QZ81e5QAWM"
+                }
+            ],
+            "services": {
+                "appinvite_service": {
+                    "other_platform_oauth_client": [
+                        {
+                            "client_id": "392859643791-65p2e60gfj0ej58tatou54l4p98e03vk.apps.googleusercontent.com",
+                            "client_type": 3
+                        }
+                    ]
+                }
+            }
+        },
+        {
+            "client_info": {
+                "mobilesdk_app_id": "1:392859643791:android:3f9e4b8fdcf499b4cf65fa",
+                "android_client_info": {
+                    "package_name": "org.openhab.habdroid"
+                }
+            },
+            "oauth_client": [
+                {
+                    "client_id": "392859643791-65p2e60gfj0ej58tatou54l4p98e03vk.apps.googleusercontent.com",
+                    "client_type": 3
+                }
+            ],
+            "api_key": [
+                {
+                    "current_key": "AIzaSyAiBGW02vum3AMZBJx_1TA__QZ81e5QAWM"
+                }
+            ],
+            "services": {
+                "appinvite_service": {
+                    "other_platform_oauth_client": [
+                        {
+                            "client_id": "392859643791-65p2e60gfj0ej58tatou54l4p98e03vk.apps.googleusercontent.com",
+                            "client_type": 3
+                        }
+                    ]
+                }
+            }
+        }
+    ],
+    "configuration_version": "1"
+}
